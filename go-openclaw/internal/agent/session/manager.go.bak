package session

import (
	"context"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/openclaw/go-openclaw/pkg/channels"
)

// Session represents a chat session
type Session struct {
	ID          string                 `json:"id"`
	Channel     channels.Channel      `json:"channel"`
	UserID      string                 `json:"user_id"`
	UserName    string                 `json:"user_name"`
	CreatedAt   time.Time            `json:"created_at"`
	LastActive  time.Time            `json:"last_active"`
	Status      string                 `json:"status"`
	Messages    []*Message             `json:"messages"`
	Metadata    map[string]interface{} `json:"metadata"`
	mu          sync.RWMutex
}

// Message represents a message in the session
type Message struct {
	ID        string    `json:"id"`
	Role      string    `json:"role"`
	Content   string    `json:"content"`
	Timestamp time.Time `json:"timestamp"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// Manager manages sessions
type Manager struct {
	sessions map[string]*Session
	lock     sync.RWMutex
}

// NewManager creates a new session manager
func NewManager() *Manager {
	return &Manager{
		sessions: make(map[string]*Session),
	}
}

// GetOrCreate gets or creates a session for a channel
func (m *Manager) GetOrCreate(channel channels.Channel) (*Session, error) {
	sessionID := channel.ID

	m.lock.RLock()
	session, ok := m.sessions[sessionID]
	m.lock.RUnlock()

	if ok {
		return session, nil
	}

	// Create new session
	session = &Session{
		ID:         sessionID,
		Channel:    channel,
		UserID:     channel.FromID,
		UserName:   channel.FromName,
		CreatedAt:  time.Now(),
		LastActive: time.Now(),
		Status:     "active",
		Messages:    make([]*Message, 0),
		Metadata:    make(map[string]interface{}),
	}

	m.lock.Lock()
	m.sessions[sessionID] = session
	m.lock.Unlock()

	log.Printf("üìù Created new session: %s", sessionID)

	return session, nil
}

// Get retrieves a session by ID
func (m *Manager) Get(id string) (*Session, bool) {
	m.lock.RLock()
	defer m.lock.RUnlock()

	session, ok := m.sessions[id]
	return session, ok
}

// GetAll returns all sessions
func (m *Manager) GetAll() []*Session {
	m.lock.RLock()
	defer m.lock.RUnlock()

	sessions := make([]*Session, 0, len(m.sessions))
	for _, session := range m.sessions {
		sessions = append(sessions, session)
	}

	return sessions
}

// AddMessage adds a message to a session
func (m *Manager) AddMessage(sessionID string, msg *Message) error {
	m.lock.Lock()
	defer m.lock.Unlock()

	session, ok := m.sessions[sessionID]
	if !ok {
		return fmt.Errorf("session not found: %s", sessionID)
	}

	session.Messages = append(session.Messages, msg)
	session.LastActive = time.Now()

	return nil
}

// GetMessages returns all messages from a session
func (m *Manager) GetMessages(sessionID string) ([]*Message, error) {
	m.lock.RLock()
	defer m.lock.RUnlock()

	session, ok := m.sessions[sessionID]
	if !ok {
		return nil, fmt.Errorf("session not found: %s", sessionID)
	}

	return session.Messages, nil
}

// GetMessages returns last N messages from a session
func (m *Manager) GetRecentMessages(sessionID string, limit int) ([]*Message, error) {
	m.lock.RLock()
	defer m.lock.RUnlock()

	session, ok := m.sessions[sessionID]
	if !ok {
		return nil, fmt.Errorf("session not found: %s", sessionID)
	}

	msgs := session.Messages
	msgCount := len(msgs)

	if msgCount <= limit {
		return msgs, nil
	}

	// Return last 'limit' messages
	return msgs[msgCount-limit:], nil
}

// UpdateStatus updates session status
func (m *Manager) UpdateStatus(sessionID string, status string) error {
	m.lock.Lock()
	defer m.lock.Unlock()

	session, ok := m.sessions[sessionID]
	if !ok {
		return fmt.Errorf("session not found: %s", sessionID)
	}

	session.Status = status
	session.LastActive = time.Now()

	return nil
}

// Delete removes a session
func (m *Manager) Delete(sessionID string) error {
	m.lock.Lock()
	defer m.lock.Unlock()

	delete(m.sessions, sessionID)

	log.Printf("üì¥ Deleted session: %s", sessionID)

	return nil
}

// Count returns the number of sessions
func (m *Manager) Count() int {
	m.lock.RLock()
	defer m.lock.RUnlock()

	return len(m.sessions)
}

// GetActiveSessions returns sessions with recent activity
func (m *Manager) GetActiveSessions(threshold time.Duration) []*Session {
	m.lock.RLock()
	defer m.lock.RUnlock()

	var sessions []*Session
	cutoff := time.Now().Add(-threshold)

	for _, session := range m.sessions {
		if session.LastActive.After(cutoff) {
			sessions = append(sessions, session)
		}
	}

	return sessions
}

// CleanupOldSessions removes sessions older than threshold
func (m *Manager) CleanupOldSessions(maxAge time.Duration) int {
	m.lock.Lock()
	defer m.lock.Unlock()

	cutoff := time.Now().Add(-maxAge)
	count := 0

	for id, session := range m.sessions {
		if session.CreatedAt.Before(cutoff) {
			delete(m.sessions, id)
			count++
		}
	}

	if count > 0 {
		log.Printf("üßπ Cleaned up %d old sessions", count)
	}

	return count
}
