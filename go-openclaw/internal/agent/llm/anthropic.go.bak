package llm

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/anthropics/anthropic-sdk-go"
)

// AnthropicClient implements Anthropic Claude API client
type AnthropicClient struct {
	apiKey  string
	model   string
	timeout time.Duration
}

// NewAnthropicClient creates a new Anthropic Claude API client
func NewAnthropicClient(apiKey, model string, timeout time.Duration) (*AnthropicClient, error) {
	if apiKey == "" {
		return nil, fmt.Errorf("API key is required")
	}

	if model == "" {
		return nil, fmt.Errorf("model is required")
	}

	return &AnthropicClient{
		apiKey: apiKey,
		model:   model,
		timeout: timeout,
	}
}

// Provider returns LLM provider name
func (c *AnthropicClient) Provider() string {
	return ProviderAnthropic
}

// Model returns LLM model name
func (c *AnthropicClient) Model() string {
	return c.model
}

// SendMessage sends a single message to Anthropic Claude API
func (c *AnthropicClient) SendMessage(ctx context.Context, req *Request) (*Response, error) {
	return c.sendMessages(ctx, []Message{req})
}

// SendMessages sends multiple messages to Anthropic Claude API
func (c *AnthropicClient) SendMessages(ctx context.Context, req *MultiMessageRequest) (*Response, error) {
	if len(req.Messages) == 0 {
		return nil, fmt.Errorf("no messages provided")
	}

	// Create Anthropic client
	client := anthropic.NewClient(c.apiKey)

	// Set timeout
	ctx, cancel := context.WithTimeout(ctx, c.timeout)
	defer cancel()

	// Prepare messages
	messages := make([]anthropic.Message, len(req.Messages))
	for i, msg := range req.Messages {
		messages[i] = anthropic.NewMessage(anthropic.MessageRole(msg.Role), msg.Content)
	}

	// Prepare request
	anthropicReq := anthropic.NewMessageParams(c.model, messages)

	// Send request
	resp, err := client.CreateMessage(ctx, *anthropicReq)
	if err != nil {
		return nil, fmt.Errorf("failed to send message: %w", err)
	}

	// Extract response
	var text string
	if len(resp.Content.Text) > 0 {
		text = resp.Content.Text[0]
	}

	return &Response{
		Text:    text,
		Usage: &Usage{
			InputTokens:  resp.Usage.InputTokens,
			OutputTokens: resp.Usage.OutputTokens,
			TotalTokens: resp.Usage.InputTokens + resp.Usage.OutputTokens,
		},
		Metadata: map[string]interface{}{
			"model": c.model,
			"stop_reason": resp.StopReason,
		},
	}
}

// StreamMessage sends a message and streams the response
func (c *AnthropicClient) StreamMessage(ctx context.Context, req *Request, handler StreamHandler) error {
	if handler == nil {
		return fmt.Errorf("stream handler is required")
	}

	client := anthropic.NewClient(c.apiKey)

	// Prepare messages
	messages := make([]anthropic.Message, len(req.Messages))
	for i, msg := range req.Messages {
		messages[i] = anthropic.NewMessage(anthropic.MessageRole(msg.Role), msg.Content)
	}

	// Create request
	anthropicReq := anthropic.NewMessageParams(c.model, messages)

	// Stream response
	eventStream := client.NewMessageStream(ctx, anthropic.MessageStreamParams{
		MaxTokens: req.MaxTokens,
		TopP:      req.TopP,
		Messages: messages,
	})

	for event := range eventStream {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-event:
			if event.Error != nil {
				return fmt.Errorf("streaming error: %w", event.Error)
			}

			switch event.Type {
			case anthropic.MessageStreamEventTypeContentBlockDelta:
				// Content block
				if event.Delta != nil && len(event.Delta.Text) > 0 {
					if err := handler(event.Delta.Text, false); err != nil {
						return fmt.Errorf("handler error: %w", err)
					}
				}

			case anthropic.MessageStreamEventTypeMessageStop:
				// Message complete
				if err := handler(event.Delta.Text, true); err != nil {
						return fmt.Errorf("final handler error: %w", err)
					}
				}

			case anthropic.MessageStreamEventTypeError:
				// Error
				if event.Type != "" {
					if err := handler(event.Type, false); err != nil {
						return fmt.Errorf("error handler: %w", err)
					}
				}
			}
		}

	return nil
}

// CallTool calls a function tool on Anthropic Claude API
func (c *AnthropicClient) CallTool(ctx context.Context, tool string, params map[string]interface{}) (*ToolResponse, error) {
	client := anthropic.NewClient(c.apiKey)

	// Build messages with tool call
	messages := []anthropic.Message{
		anthropic.NewAssistantMessage("You are a helpful assistant."),
	}

	// Add tool call
	toolCall := anthropic.Tool{
		Name: tool,
		Input: params,
	}

	anthropicReq := anthropic.NewMessageParams(c.model, messages)
	anthropicReq.Tools = []anthropic.Tool{toolCall}

	// Send request
	resp, err := client.CreateMessage(ctx, *anthropicReq)
	if err != nil {
		return nil, fmt.Errorf("failed to call tool: %w", err)
	}

	// Extract tool result
	var toolResult map[string]interface{}
	if len(resp.Content.ToolUse) > 0 {
		toolResult = resp.Content.ToolUse[0].Input
	}

	return &ToolResponse{
		Name:   tool,
		Params: toolResult,
	}
}

// Close closes the client
func (c *AnthropicClient) Close(ctx context.Context) error {
	// No-op for stateless API client
	return nil
}

// StreamHandler handles streaming response chunks
type StreamHandler func(chunk string, done bool) error
